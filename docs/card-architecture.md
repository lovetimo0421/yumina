# Card Architecture Research

## 1. SillyTavern V3 Card Format

SillyTavern character cards are JSON objects conforming to the Character Card V2/V3 specification (originally proposed by the TavernAI community). A card contains:

- **Character data**: `name`, `description`, `personality`, `scenario`, `system_prompt`, `first_mes`, `mes_example`
- **Extensions**: An open-ended `extensions` object carrying feature-specific data:
  - `regex_scripts` — Array of find-and-replace rules applied to messages before display
  - `character_book` — Embedded lorebook (entries with keywords, content, insertion positions)
  - Custom extension fields used by plugins (e.g., JS-Slash-Runner configuration)
- **Creator metadata**: `creator`, `creator_notes`, `tags`, `character_version`

Cards are distributed as **PNG files with embedded JSON** — the character data is encoded into the PNG's tEXt chunk (key: `chara`, value: base64-encoded JSON). This allows cards to carry both an avatar image and the full character definition in a single file. Tools like `charaRead()` extract the JSON; `charaWrite()` embeds it back.

The V3 spec adds `assets` (external resource references), `group_only_greetings`, and a formalized `extensions` namespace, but the vast majority of cards in circulation are V2.

---

## 2. Three Card Paradigms

### Type 1: Pure Chat (No UI)

Standard character conversation. No game mechanics, no custom UI, no state management. The AI responds with prose or dialogue and the frontend renders it as plain text (or markdown).

This is the majority of SillyTavern cards — character personas, scenario setups, roleplay prompts. The card's `system_prompt` and `character_book` entries guide the AI's behavior, but there is no programmatic UI layer.

**SillyTavern mechanics:**
- `system_prompt` sets the character's persona and behavioral rules
- `character_book` entries inject context when keyword-triggered (lorebook)
- No `regex_scripts`, no external scripts, no variable system
- Output is rendered as-is with basic markdown/HTML support

**Yumina equivalent:** Default world with entries. System prompt becomes a top-positioned system entry. Character book entries become `WorldEntry` objects with keywords and position mapping. No display transforms or custom components needed.

---

### Type 2: Per-Reply UI ("Chat IS the Game")

Each AI message contains the full game UI. The AI outputs structured content with semantic markers, and regex scripts transform those markers into styled HTML before display. Every message independently renders through the full regex pipeline, so each message is its own UI snapshot.

**NIAH (Needles in a Haystack)** is the canonical example — a survival/horror card where each message contains an ASCII-art HUD, status bars, inventory, and interactive choice buttons, all generated by the AI and styled by regex transforms.

**SillyTavern mechanics:**

- **character_book entries** define game rules, NPC databases, phase mechanics, and output format requirements. These are the "instructions" that teach the AI how to structure its output with the expected markers.

- **extensions.regex_scripts** (25+ regex find-and-replace rules) form the rendering pipeline:
  - Strip internal reasoning blocks (e.g., `<think>...</think>`, `<hidden>...</hidden>`)
  - Transform semantic markers into styled HTML (e.g., `[HP: 75/100]` becomes a colored health bar)
  - Create interactive choice buttons from structured choice lists
  - Apply atmospheric effects (glowing text, colored backgrounds, CSS animations)
  - Each regex rule has a `findRegex`, `replaceString`, scope flags (`user`/`ai`/`slash`), and optional `scriptContent` for complex replacements

- **Variable system** uses `<UpdateVariable>` blocks with `<JSONPatch>` arrays (RFC 6902 JSON Patch operations). The AI outputs these blocks within its response; ST's variable system parses and applies them. This allows the AI to maintain complex game state (HP, inventory, location, NPC relationships) across messages.

- **Per-message rendering**: Every message independently passes through all regex scripts. There is no persistent UI frame — each message contains its own complete UI snapshot. Scrolling back through chat history shows the game state at each point in time.

**Yumina equivalent:**

Display transforms (Phase 12). This is a nearly identical mechanism — an array of `{ pattern, replacement, flags }` objects applied to message content before rendering. The NIAH world has already been ported to Yumina with 17+ display transforms derived from the original card's regex scripts.

Key differences from ST's regex_scripts:
- Yumina display transforms are simple pattern/replacement pairs (no script contexts)
- Transforms are defined at the world level, not embedded in card extensions
- Variable directives use `[var: op value]` syntax parsed by the engine's ResponseParser, rather than `<UpdateVariable>` + JSONPatch
- The rendering pipeline is: protect code blocks, escape HTML, render markdown, restore code blocks, apply display transforms, DOMPurify sanitize

---

### Type 3: Persistent UI ("Chat is WITHIN the Game")

A full application takes over the screen. Chat messages are hidden or minimized. Game state is managed externally by JavaScript, not by the AI's message content. The **Shelter** card is the canonical example — a post-apocalyptic base management game with a React dashboard.

**SillyTavern mechanics:**

- **Single regex script**: A catch-all pattern (`/.+/s` — match everything including newlines) replaces ALL message content with a `<script>` tag. This script tag uses jQuery's `.load()` to fetch and inject an external React application into the message container.

- **JS-Slash-Runner scripts** provide the game's infrastructure:
  - **ZOD schema**: 50+ typed variables across categories (world state, vault resources, faction relationships, NPC data, research progress). This defines the shape of the entire game state.
  - **MVU (Model-View-Update)**: A state management bundle that maintains the game model, processes updates, and triggers view re-renders. Acts as an intermediary between the AI responses and the React UI.
  - **Message hiding**: jQuery commands hide the native chat interface, leaving only the game dashboard visible.

- **External React app** (5.5MB bundled): A complete React application that:
  - Communicates with SillyTavern via `postMessage` / custom events
  - Reads and writes game variables through the MVU system
  - Renders a full game dashboard: resource meters, facility management, NPC roster, inventory system, diplomacy interface, research tree
  - Has its own component hierarchy, styling, and routing

- **Persistence**: The React app persists across messages. It is NOT re-rendered per message like Type 2 cards. It maintains its own internal state and synchronizes with ST's variable system. Sending a new message triggers an AI response, which produces state update directives, which the MVU system applies, which the React app observes and re-renders.

**Yumina equivalent:**

Custom components (Phase 11) with the `useYumina()` hook + immersive layout mode (Phase 11C).

- The external React app becomes a **TSX custom component** defined in the world's `customComponents` array
- Components are compiled via Sucrase + `new Function()` sandbox at runtime
- The `useYumina()` hook exposes `sendMessage(text)` and `setVariable(id, value)`, replacing the postMessage/MVU communication layer
- `layoutMode: "immersive"` makes the game panel full-screen with chat as a floating overlay, replacing jQuery message hiding
- Game state lives in Yumina's `GameStateManager` (reactive, observer pattern), replacing the MVU bundle
- Variables are defined in the world's `variables[]` array with Zod-validated types, replacing the external ZOD schema

---

## 3. Key Differences Table

| Aspect | Pure Chat | Per-Reply (NIAH) | Persistent (Shelter) |
|--------|-----------|-------------------|----------------------|
| UI Rendering | Text only | Regex transforms per message | External React app |
| State Source | AI memory only | AI-maintained variables | External state manager |
| Chat Visibility | Full | Full (with styled elements) | Hidden (latest only) |
| Screen Usage | Chat only | Chat with embedded UI | Full-screen game |
| Complexity | Low | Medium | High |
| ST Mechanism | None | regex_scripts + character_book | JS-Slash-Runner + external app |
| Yumina Mechanism | Default | displayTransforms + entries | customComponents + immersive mode |
| Message Independence | N/A | Each message is self-contained UI | Messages are state update carriers |
| Portability | Trivial | Moderate (regex conversion needed) | Difficult (app must be rewritten) |

---

## 4. Yumina Mapping Guide

### ST to Yumina Concept Mapping

| SillyTavern | Yumina | Notes |
|-------------|--------|-------|
| Character card | WorldDefinition | Complete game package |
| system_prompt | Entry (role="system", position="top") | Always-send system entry |
| first_mes (greeting) | Entry (role="greeting", position="greeting") | First message content |
| character_book entries | entries[] (WorldEntry) | With role/position/keywords |
| regex_scripts | displayTransforms[] | Pattern to replacement, applied before render |
| extensions.depth_prompt | Entry with position="depth" | Injected N messages from end |
| `<UpdateVariable>` + JSONPatch | `[var: op value]` directives | Parsed by ResponseParser |
| ZOD schema (MVU variables) | variables[] | Typed state definitions in world |
| JS-Slash-Runner scripts | N/A (not needed) | Engine handles state natively |
| MVU (Model-View-Update) | GameStateManager | Reactive state with observer pattern |
| External React app | customComponents (TSX) | Compiled via Sucrase, sandboxed |
| jQuery message hiding | layoutMode: "immersive" | Native layout mode |
| response_format | settings.structuredOutput | JSON mode toggle |
| character_book.scan_depth | Entry tokenBudget / priority | Controls how far back keywords are scanned |
| character_book.position | Entry position field | "before_char" / "after_char" / "depth" mapping |
| alternate_greetings | Multiple greeting entries | Each greeting is a separate entry |
| mes_example | Entry (role="examples") | Example dialogue for few-shot prompting |
| tags | WorldDefinition metadata | Categorization and search |

### Import Paths

**V2 Card to Yumina:**

Already supported via `importSillyTavernCard()` in the engine package. Handles:
- V1 and V2 character card formats (auto-detected)
- character_book entries converted to WorldEntry with position mapping (`before_char` / `after_char` / `depth` mapped to Yumina positions)
- Role inference from entry content (system instructions vs. character dialogue vs. world lore)
- InitVar extraction: entries containing variable initialization patterns are parsed into `variables[]` definitions
- Greeting extraction: `first_mes` and `alternate_greetings` become greeting-positioned entries

**Per-Reply cards (Type 2):**

Import the character_book as entries (supported by the importer). Regex scripts must be **manually converted** to display transforms because the formats differ:
- ST regex_scripts support JavaScript replacement functions, scope flags (user/ai/slash), and `scriptContent` for complex logic
- Yumina displayTransforms are simple `{ pattern: string, replacement: string, flags?: string }` objects
- Most ST regex rules can be directly converted (literal find/replace), but rules using `scriptContent` or complex replacement functions require manual adaptation
- The NIAH port demonstrates this conversion process — 25+ ST regex rules became 17 Yumina display transforms

**Persistent cards (Type 3):**

Cannot auto-import external applications. The React app bundled with the card must be **recreated** as a Yumina custom component:
- Extract the game logic and UI from the external app
- Rewrite as a TSX custom component using `useYumina()` for state access
- Replace postMessage/MVU communication with `sendMessage()` and `setVariable()` calls
- Replace external ZOD schema with Yumina `variables[]` definitions
- Set `layoutMode: "immersive"` to replicate the full-screen takeover

This is the most labor-intensive import path. There is no shortcut — the external app is arbitrary JavaScript/React code that must be understood and rewritten to work within Yumina's component sandbox.

---

## 5. Design Implications for Yumina

### uiMode Setting

Rather than auto-detecting from card content, worlds should explicitly declare their UI paradigm:

- **`"chat"`** — Pure conversation. No game panel needed. Messages render as text/markdown. This is the default for simple character cards and roleplay scenarios.

- **`"per-reply"`** — Display transforms render game UI in each message. Chat is the primary view, but messages contain structured visual elements (health bars, choice buttons, styled regions). The game panel may show variable state as a sidebar.

- **`"persistent"`** — Full-screen custom component. Chat is secondary (overlay or hidden). The custom component owns the screen and communicates with the AI through the engine. Messages are state update carriers, not the primary UI.

This replaces the previous `layoutMode` setting which was an implementation detail (split/game-focus/immersive) rather than a semantic declaration of the card's paradigm. The `layoutMode` values describe *how* the screen is divided; `uiMode` describes *what* the card fundamentally is.

The mapping between uiMode and layoutMode:
- `"chat"` defaults to split layout (chat fills the main area, optional sidebar)
- `"per-reply"` defaults to split or game-focus (chat is primary, game panel shows state)
- `"persistent"` defaults to immersive (game panel is full-screen, chat overlays)

Creators can override the default layout, but the uiMode communicates intent.

### Why Not Auto-Detect?

A world with display transforms might still be primarily chat-focused (e.g., just formatting quotes differently or applying light styling). And a world with custom components might use them as a sidebar widget rather than a full-screen takeover. The creator's intent matters more than the presence of features.

Auto-detection would also create fragile heuristics:
- "Has display transforms" does not mean "per-reply game UI"
- "Has custom components" does not mean "persistent full-screen game"
- "Has variables" does not mean "has game mechanics"

Explicit declaration is simpler, more predictable, and gives creators control over how their world is experienced.

### Implications for the Import Pipeline

The `importSillyTavernCard()` function could set a default `uiMode` based on heuristics during import:
- Card has regex_scripts with UI-generating patterns? Suggest `"per-reply"`
- Card has JS-Slash-Runner references? Suggest `"persistent"`
- Otherwise? Default to `"chat"`

But this should be a suggestion the creator can override, not an automatic decision.

---

*This document is a reference for Yumina development. It reflects the SillyTavern ecosystem as of early 2025.*
